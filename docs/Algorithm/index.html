<!DOCTYPE html>
<html>
    <head>
        <title>LAMAS Project</title>
        <meta charset="UTF-8">
        <script type="text/javascript" src="https://unpkg.com/vis-data@latest/peer/umd/vis-data.min.js"></script>
        <script type="text/javascript" src="https://unpkg.com/vis-network@latest/peer/umd/vis-network.min.js"></script>
        <script type="text/javascript" src="/The-Number-Game/script/genNavBar.js"></script>
        <link rel="stylesheet" type="text/css" href="https://unpkg.com/vis-network/styles/vis-network.min.css" />
        <link rel="stylesheet" href="/The-Number-Game/css/style.css">
        <link rel="stylesheet" href="/The-Number-Game/css/stylebar.css">
    </head>

    <body onload="genNavBar('navBar');">
        <!-- Load and generate the navigation bar -->
        <div id="navBar" class="topnav"></div>
        <div style='height:10px'></div>
        
        <div class="row">
            <div class="columnPadding"> &nbsp; &nbsp; &nbsp; &nbsp; </div>
            <div class="columnText textBox">
                <h1>
                    solvability using logical sentences
                </h1>
                <p>
                    In this section we will have a closer look at how we can use the previously defined logical sentences in order to create an algorithm to derive the solvability of each different solutions.
                </p>

                <h2>
                    The approach of the algorithm
                </h2>
                <p>
                    Using the preveously defined sentences we can evaluta after how many itterarions of anounching "I do not know the numbers" a number is removed from the model. As noted before, we can remove a state from the model when it is a singleton from the view of the current agent. Thus, if we have a sequence of anouncements and we can show that the atom $(x,y)$ holds as well as $K_i(x,y)$ holds where $i$ is the current agents (i.e. the state exists and it is a singleton from the perspecive of agent $i$). Then we know that they should know that they know at that iteration if that state corresponds to the sum/product received by the agent at the start.
                </p>

                <p>
                    Using this itterative method we can start by evaluate <bf>ADD FORMULA FOR SINGLETON IN STEP 1</bf> for each pair $(x,y)$ to see if they can be deduced by agent $i$ in the first step. Then we evaluate <bf>ADD FORMULA FOR SINGLETON IN STEP 2</bf> to see which states can be deduced by agent $j$ after the initial anouncement. This process can be repeated by adding anouncements of the agents in an alternating fashin. The algorithm terminates when no states where removed after 2 consecutive iterations. 
                </p>

                <p>
                    We will now argue why this is a valid stopping criterion for the algorithm. Assume that agent $i$ anounced that they do not know and that not states where removed from the model by this announcement. Then, if agent $j$ anounces that they do not know and this also does not remove any additional states, then agent $i$ considers the model from exactly the same perspective as they did 2 anounchements ago. Hence there will never be any additional states which will be removed from that point onward. Note that this condision does not give any guarantees that the model will be empty after the algorithm, i.e. there is no guarantees that all generated number pairs can be deduced using a sequence of "I do not know" annouchements.
                </p>


                <h1>
                    solvability using programming
                </h1>
                <p>
                    In this section we will look at how we can implement the above algorithm in an efficient manner. The algorithm that will be described was also implemented in JavaScript and is included in the demo page of the report.
                </p>

                <h2>
                    Initialization
                </h2>
                <p>
                    We will start by creating a set of <i>candidate_pairs</i> containing all possible random numbers that can be considered. Note that in the original puzzle they use a inclusive lower bound of 1 and an exclusive upper bound of 100. Also note that there is no difference between $(x,y)$ and $(y,x)$ and only one of them needs to be added to the <i>candidate_pairs</i>.
                </p>

                <p>
                    Next we will create 2 function <i>generate_sums(candidate_pairs)</i> and <i>generate_products(candidate_pairs)</i> which compute a map containing the sum or product as the key and an array of pairs which sum or multiply to the key as the value. Note that these sets correspond to the relations for Alice and Bob in our formal model.
                </p>

                <h2> Main loop</h2>
                <p>
                    We will loop until no states where removed for 2 consecutive iterations. We loop over the map of <i>product</i>/<i>sum</i> (depending on the starting agent) and remove all pairs which are the only pair corresponding to a <i>product</i>/<i>sum</i> value. In other words, we remove all states which do not have a relation to another state.
                </p>
                <p>
                    Then we recompute the <i>product</i> and <i>sum</i> value between each step. It is recommended to also keep track of which nodes where removed durring which step of the iteration on order to obtain the list of solvable initial conditions and after how many steps they are solved.
                </p>

            </div>
            <div class="columnPadding"> &nbsp; &nbsp; &nbsp; &nbsp; </div>
        </div>
    </body>
</html>
